package Object_Mid.Polymorphic;

//动态绑定机制:
/*
1.调用对象方法时候, 该方法会和该对象的运行类型绑定, 从子类开始找方法(只找override的)
  但是编译时只保存了父类(编译类型)方法, 不能调用子类特有方法  --> 解决: 向下转型
  如果方法中出现了变量(不管有没有this), 首先会在当前类中查找对应的变量, 如果找不到则会向父类中继续查找, 直到找到为止(就近原则)
2.调用对象属性时候, 直接看编译类型
 */


//关于多态的一点总结
/*  多态的好处:
虽然Dog d = new Dog()可以调用父类及其特有方法,但是Dog d就只能接受dog对象,不能接收Cat对象
但是用Animal a接收就很灵活: 可以接收任意的子类对象; 可以调用父类方法,想调用子类特有方法时候还可以向下转型;
                         同时也可以将Dog转对象换成Cat对象 (需要先转型成Cat对象)
 */


